{"version":3,"sources":["styles/TranslateForm.module.css","styles/TranslatorHeader.module.css","styles/App.module.css","utils/TranslateUtils/constants.ts","utils/TranslateUtils/translate.ts","utils/TranslateUtils/index.ts","components/TranslateForm.tsx","components/TranslatorHeader.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","API","API_KEY","fetch","require","langLst","langDet","transD","getLangList","api_url","ui","a","method","then","response","json","data","catch","err","langDetect","text","textTranslate","lang","getSupportedLangList","languageDetect","hint","join","translate","format","TranslateUtils","TranslateForm","useState","from","to","source","translated","languages","languageNames","state","setState","from_ta","useRef","to_ta","from_sel","to_sel","length","dat","langs","Object","entries","key","val","push","languagesFrom","languageNamesFrom","className","styles","container","paragraph","onChange","e","target","value","current","map","elem","idx","selected","input","ref","onKeyPress","charCode","preventDefault","console","log","direction","placeholder","output","TranslatorHeader","soft_name","App","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","error","ReactDOM","render","StrictMode","document","getElementById","URL","process","href","origin","addEventListener","headers","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.c74e2fdb.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"TranslateForm_container___23oz\",\"from\":\"TranslateForm_from__U57j8\",\"to\":\"TranslateForm_to__2LYLE\",\"input\":\"TranslateForm_input__3wSb5\",\"output\":\"TranslateForm_output__27FlH\",\"paragraph\":\"TranslateForm_paragraph__1cSzz\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"TranslatorHeader_container__3nVUG\",\"soft_name\":\"TranslatorHeader_soft_name__fdAl3\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__1TtKj\",\"App-logo\":\"App_App-logo__367dZ\",\"App-logo-spin\":\"App_App-logo-spin__1W6Dz\",\"App-header\":\"App_App-header__1074e\",\"App-link\":\"App_App-link__1iHtM\"};","export const API: string = 'https://translate.yandex.net/api/v1.5/tr.json'\nexport const API_KEY: string = 'trnsl.1.1.20200404T213846Z.20d6053846cad811.5f7cefc53471549d122a16027460dd47a7f3494b'\n","import { API, API_KEY } from './constants'\nimport * as T from './types'\n\nconst fetch = require('node-fetch')\n\nconst langLst: T.ICacheDict = {}\nconst langDet: T.ICacheDict = {}\nconst transD: T.ICacheDict = {}\n\nasync function getLangList(api_url: string, ui: string): Promise<T.LangListAPIResponse> {\n  return fetch(api_url, { method: 'POST' })\n    .then((response: any) => response.json())\n    .then((data: T.ILangListAPIResponse) => {\n      langLst[ui] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      return err\n    })\n}\n\nasync function langDetect(api_url: string, text: string): Promise<T.DetectAPIResponse> {\n  return fetch(api_url, { method: 'POST' })\n    .then((response: any) => response.json())\n    .then((data: T.IDetectAPIResponse) => {\n      langDet[text] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      return err\n    })\n}\n\nasync function textTranslate(api_url: string, text: string, lang: string): Promise<T.TranslateAPIResponse> {\n  return fetch(api_url, { method: 'POST' })\n    .then((response: any) => response.json())\n    .then((data: T.ITranslateAPIResponse) => {\n      transD[`${text}_${lang}`] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      return err\n    })\n}\n\nexport async function getSupportedLangList(ui: string): Promise<T.LangListAPIResponse> {\n\n  if (langLst[ui]) {\n    return langLst[ui] as T.ILangListAPIResponse\n  }\n\n  let api_url = `${API}/getLangs?key=${API_KEY}&ui=${ui}`\n\n  return getLangList(api_url, ui)\n}\n\nexport async function languageDetect(text: string, hint?: string[]): Promise<T.DetectAPIResponse> {\n  if (langDet[text]) {\n    return langDet[text] as T.IDetectAPIResponse\n  }\n\n  let api_url = `${API}/detect?key=${API_KEY}&text=${text}`\n\n  if (hint) {\n    api_url = `${API}/detect?key=${API_KEY}&text=${text}&hint=${hint.join(',')}`\n  }\n\n  return langDetect(api_url, text)\n}\n\nexport async function translate(text: string, lang: string, format?: string): Promise<T.TranslateAPIResponse> {\n  if (transD[`${text}_${lang}`]) {\n    return transD[`${text}_${lang}`] as T.ITranslateAPIResponse\n  }\n\n  let api_url = `${API}/translate?key=${API_KEY}&text=${text}&lang=${lang}`\n\n  if (format) {\n    api_url = `${API}/translate?key=${API_KEY}&text=${text}&lang=${lang}&format=${format}`\n  }\n\n  return textTranslate(api_url, text, lang)\n}\n","import * as TranslateUtils from './translate'\n\nexport default TranslateUtils\n","import React, {useState, useRef, ChangeEvent} from 'react'\nimport * as T from '../utils/types'\nimport TranslateUtils from '../utils/TranslateUtils'\nimport * as TT from '../utils/TranslateUtils/types'\n\nimport styles from '../styles/TranslateForm.module.css'\n\nconst TranslateForm = () => {\n    const [state, setState] = useState({\n        from: '',\n        to: '',\n        source: '',\n        translated: '',\n        languages: [],\n        languageNames: []\n    } as T.IState)\n\n    const from_ta: React.RefObject<HTMLTextAreaElement> = useRef<HTMLTextAreaElement>(null)\n    const to_ta: React.RefObject<HTMLTextAreaElement> = useRef<HTMLTextAreaElement>(null)\n    const from_sel: React.RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null)\n    const to_sel: React.RefObject<HTMLInputElement> = useRef<HTMLInputElement>(null)\n\n    let {from, to, source, translated, languages, languageNames} = state\n\n    if(!languages.length) {\n        TranslateUtils.getSupportedLangList('en').then(data => {\n            const dat: TT.ILangListAPIResponse = data as TT.ILangListAPIResponse\n\n            if(dat.langs) {\n                for(const[key, val] of Object.entries(dat.langs)){\n                    languages.push(key)\n                    languageNames.push(val)\n                }\n\n                from = 'auto'\n                to = languages[0]\n\n                setState({\n                    from: from,\n                    to: to,\n                    source: source,\n                    translated: translated,\n                    languages: languages,\n                    languageNames: languageNames\n                } as T.IState)\n            }\n        })\n    }\n\n    const handleFromChanged = (e: ChangeEvent<HTMLSelectElement>) => {\n\n        from = e.target.value\n\n        if(from_ta && from_ta.current) {\n            source = from_ta.current.value\n        }\n\n        if(to_ta && to_ta.current) {\n            translated = to_ta.current.value\n        }\n\n        setState({\n            from: from,\n            to: to,\n            source: source,\n            translated: translated,\n            languages: languages,\n            languageNames: languageNames\n        })\n    }\n\n    const handleToChanged = (e: ChangeEvent<HTMLSelectElement>) => {\n\n        to = e.target.value\n\n        if(from_ta && from_ta.current) {\n            source = from_ta.current.value\n        }\n\n        if(to_ta && to_ta.current) {\n            translated = to_ta.current.value\n        }\n\n        setState({\n            from: from,\n            to: to,\n            source: source,\n            translated: translated,\n            languages: languages,\n            languageNames: languageNames\n        })\n    }\n\n    const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n        if(e.charCode === 13){\n            e.preventDefault()\n\n            console.log('enter pressed')\n\n            if(from_sel && from_sel.current) {\n                from = from_sel.current.value\n            }\n\n            if(to_sel && to_sel.current) {\n                to = to_sel.current.value\n            }\n\n            if(from_ta && from_ta.current) {\n                source = from_ta.current.value\n            }\n\n            if(to_ta && to_ta.current) {\n                translated = to_ta.current.value\n            }\n\n            let direction = ''\n\n            if(from === '' || from === 'auto') {\n                direction = to\n            }\n            else {\n                direction = `${from}-${to}`\n            }\n\n            console.log(direction)\n\n            if(source) {\n                TranslateUtils.translate(source, direction).then(data => {\n                    const dat: TT.ITranslateAPIResponse = data as TT.ITranslateAPIResponse\n\n                    if(dat.text) {\n                        translated = dat.text[0]\n\n                        setState({\n                            from: from,\n                            to: to,\n                            source: source,\n                            translated: translated,\n                            languages: languages,\n                            languageNames: languageNames\n                        })\n                    }\n                })\n            }\n            else {\n                setState({\n                    from: from,\n                    to: to,\n                    source: source,\n                    translated: translated,\n                    languages: languages,\n                    languageNames: languageNames\n                })\n            }\n        }\n    }\n\n    const languagesFrom: string[] = ['auto', ...languages] \n    const languageNamesFrom: string[] = ['auto', ...languageNames]\n\n    return (\n        <div className={styles.container}>\n            <div className={styles.from}>\n                <p className={styles.paragraph}>\n                    <select onChange={handleFromChanged}>\n                        {languageNamesFrom.map((elem, idx) => {\n                            if(idx === 0){\n                                return <option selected value={languagesFrom[idx]}>{elem}</option>\n                            }\n                            else {\n                                return <option value={languagesFrom[idx]}>{elem}</option>\n                            }\n                        })}\n                    </select>\n                </p>\n                <p className={styles.paragraph}>\n                    <textarea\n                    className={styles.input} \n                    ref={from_ta} \n                    onKeyPress={handleKeyPress} \n                    placeholder='Input text needed to translate'>{source}</textarea>\n                </p>\n            </div>\n            <div className={styles.to}>\n                <p className={styles.paragraph}>\n                    <select onChange={handleToChanged}>\n                        {languageNames.map((elem, idx) => {\n                            if(idx === 0){\n                                return <option selected value={languages[idx]}>{elem}</option>\n                            }\n                            else {\n                                return <option value={languages[idx]}>{elem}</option>\n                            }\n                        })}\n                    </select>\n                </p>\n                <p className={styles.paragraph}>\n                    <textarea className={styles.output} ref={to_ta} value={translated}/>\n                </p>\n            </div>\n\n        </div>\n    )\n}\n\nexport default TranslateForm","import React from 'react'\nimport styles from '../styles/TranslatorHeader.module.css'\n\nconst TranslatorHeader = () => {\n    return (\n        <div className={styles.container}>\n            <span className={styles.soft_name}>Track translator</span>\n        </div>\n    )\n}\n\nexport default TranslatorHeader","import React from 'react';\nimport TranslateForm from './TranslateForm'\nimport TranslatorHeader from './TranslatorHeader'\nimport styles from '../styles/App.module.css';\n\nfunction App() {\n  return (\n    <div className={styles.App}>\n      <TranslatorHeader/>\n      <TranslateForm />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}